[
  {
    "objectID": "proposal.html",
    "href": "proposal.html",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "",
    "text": "#importing libraries\nimport pandas as pd"
  },
  {
    "objectID": "proposal.html#dataset",
    "href": "proposal.html#dataset",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Dataset",
    "text": "Dataset\n\n#importing csv into pandas dataframe\nimport_data = pd.read_csv(\"data/soccer21-22.csv\")\n\nFull Preview of Data\n\n\n\n\n\n\n\n\nvariable\nclass\ndescription\n\n\n\n\nDate\ncharacter\nThe date when the match was played\n\n\nHomeTeam\ncharacter\nThe home team\n\n\nAwayTeam\ncharacter\nThe away team\n\n\nFTHG\ndouble\nFull time home goals\n\n\nFTAG\ndouble\nFull time away goals\n\n\nFTR\ncharacter\nFull time result\n\n\nHTHG\ndouble\nHalftime home goals\n\n\nHTAG\ndouble\nHalftime away goals\n\n\nHTR\ncharacter\nHalftime results\n\n\nReferee\ncharacter\nReferee of the match\n\n\nHS\ndouble\nNumber of shots taken by the home team\n\n\nAS\ndouble\nNumber of shots taken by the away team\n\n\nHST\ndouble\nNumber of shots on target by the home team\n\n\nAST\ndouble\nNumber of shots on target by the away team\n\n\nHF\ndouble\nNumber of fouls by the home team\n\n\nAF\ndouble\nNumber of fouls by the away team\n\n\nHC\ndouble\nNumber of corners taken by the home team\n\n\nAC\ndouble\nNumber of corners taken by the away team\n\n\nHY\ndouble\nNumber of yellow cards received by the home team\n\n\nAY\ndouble\nNumber of yellow cards received by the away team\n\n\nHR\ndouble\nNumber of red cards received by the home team\n\n\nAR\ndouble\nNumber of red cards received by the away team"
  },
  {
    "objectID": "proposal.html#introduction",
    "href": "proposal.html#introduction",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Introduction",
    "text": "Introduction\nEvan Gower’s work on Kaggle has made it possible to obtain statistics from 380 matches, giving us a detailed glimpse at the English Premier League season of 2021–2022. Along with comprehensive statistics for both home and away sides, such as goals, shots, fouls, and cards, it also provides important game information such team names, match dates, and referees. This dataset, which contains data on halftime performance as well as full-time results, is an invaluable resource for anyone wishing to examine the factors that affect football match outcomes, from individual player affects to team plans.\nDataset Description:\nThe 2021–2022 English Premier League (EPL) season’s match-day statistics are contained in this dataset, which is sourced from Evan Gower’s work on Kaggle. It is taken from the official Premier League website and has been carefully cleaned. It includes 380 matches, which represents the whole season. Every entry contains an abundance of information, such as the teams involved, the date of the match, the referee, and a variety of in-game statistics for both the home and away sides, including goals, shots, fouls, and cards. It also provides full-time results and halftime analytics, providing a detailed analysis of each match’s dynamics. This dataset offers a basis for more in-depth research into the variables impacting team performance and match results in addition to providing a numerical narrative of the season.\nReasons for Choosing this Dataset:\nThis dataset captures the attention of millions because of the rich detail and storytelling potential. It is a goldmine for football enthusiasts and can provide deep details within one of the world’s most followed sports leagues. Football is a tasteful concoction of skill, strategy, and raw athleticism. This complex tapestry allows for a broad spectrum of unique opportunities to be statistically explored: fouls affecting game outcomes, team discipline, and shot efficacy. It also enables a multifaceted investigation into the relationship between in-game occurrences and success or failure, offering insights that may be of use to observers, coaches, and even players who are trying to improve their tactics. By include halftime data, the analysis gains additional depth and an interesting new perspective on momentum fluctuations within games."
  },
  {
    "objectID": "proposal.html#questions",
    "href": "proposal.html#questions",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Questions",
    "text": "Questions\nQuestion 01: What is the connection between in-game metrics such as shots on goal, fouls committed, and cards received, and the outcomes of soccer matches? Can these metrics help in creating a predictive model to forecast whether the match results will favor the home or away team?\nQuestion 02: How do the outcomes of soccer matches vary under the premise that all games concluded at halftime? How does this disparity differ from team to team, and what is the influence of the overall outcome of the league championship?"
  },
  {
    "objectID": "proposal.html#analysis-plan",
    "href": "proposal.html#analysis-plan",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Analysis plan",
    "text": "Analysis plan\n\nFor Question 01:\nIntroduction: The first query explores the complex connections between in-game metrics—like shots on goal, fouls, and cards—and how those relationships affect the results of football matches. Our goal is to use these factors to investigate if they can accurately forecast match outcomes that will benefit the home team or the away team. This question is especially fascinating since it addresses fundamental football dynamics and provides information on how different gameplay elements affect a team’s eventual success or failure.\nThe variables involved: Full-time home and away goals (\"FTHG\" and \"FTAG\") are crucial indicators of match outcomes. Full-time results (“FTR”) will serve as the target variable for predictive modeling. Number of shots taken by the home and away team (“HS” and “AS”) and shots on target (“HST” and “AST”) reflect attacking performance. Number of fouls by the home and the away team (“HF” and “AF”) and cards received (“HY”, “AY”, “HR”, and “AR”) indicate team discipline and aggression.\nData Preparation: Combining match information with team-level season summaries will indeed provide valuable context for analysis and assist in identifying trends and outliers. The dataset’s consistency across all rows and columns, without any missing or erroneous values, ensures the reliability of our analysis. Additionally, no additional calculations or adjustments to rows are required, streamlining the process for further analysis.\nAnalysis: The dataset will be partitioned into training and testing sets to aid in model development and assessment. Regression techniques, including logistic regression or decision trees, will be applied to unveil associations between in-game performance metrics and match outcomes. This examination will enable the identification of patterns and relationships pivotal for constructing predictive models aimed at determining match results.\nDiscussion: The initial examination of the data, which concentrated on factors like as cards, fouls, and shots on goal, points to a complex relationship between these measurements and game results. Higher foul and card counts may not always indicate aggressive play, but shots on target and other planned offensive efforts may imply a more direct correlation between winning and succeeding. Because of the data’s consistency and lack of missing values, the analysis is streamlined and these associations may be examined in greater detail. Predictive modelling and trend analysis may provide trends that support received wisdom in football or unearth winning unexpected tactics.\n\n\nFor Question 02:\nIntroduction: In question two, we analyze a hypothetical scenarios to offer practical insights derived from the European Premier League’s 22nd season. By exploring how matches might end at halftime, we aim to analyze the real-world dynamics of team performance. Specifically, we will investigate whether successful teams exhibit early aggression in the first half or stage comebacks in the second half, and whether team rankings reflect consistent performance or fluctuate based on halftime strategies. This analysis offers practical implications for coaching strategies, player development, and tactical approaches, providing actionable insights to enhance team performance and strategic decision-making in professional football. By understanding the significance of second-half performances and their impact on league standings, teams can refine their approaches to enhance their competitive edge and adapt to the evolving landscape of professional football.\nThe variables involved: Full-time home and away goals (“FTHG” and “FTAG”) are necessary to determine team placement. Full-time results (“FTR”) denote the final actual outcome of the match. Half-time goals for the home and away teams, as well as the half-time result (“HTHG”, “HTAG”, and “HTR”), are important variables for the premise of our question. Additionally, the home team and away team (“HomeTeam” and “AwayTeam”) will identify who will win the league in our situation.\nData Preparation: In the data preparation phase, thorough checks ensure the integrity and consistency of the dataset. Any identified discrepancies are meticulously documented to ensure transparency. Visualizations are employed to illustrate changes in match outcomes and league standings, providing insights into the impact of simulated halftime results on soccer match dynamics and championship outcomes. Notably, the dataset exhibits no missing values.\nAnalysis: The dataset is organized chronologically, facilitating the computation of halftime results based on goals scored by both home and away teams (HTHG and HTAG). These halftime results are then compared with full-time results (FTR). A function is developed to iterate through the data, calculating halftime results (win, draw, loss) for each team and ranking them based on points. The recalibration of match outcomes assumes all games conclude at halftime, enabling a simulated scenario where leading teams at halftime are credited with wins, and tied matches result in draws for both teams. The reevaluated outcomes are subsequently contrasted with current league standings to identify any shifts in team rankings and overall league dynamics. Visualizations are utilized to enhance the interpretation of play styles and consistent team performance.\nDiscussion: The crucial significance that second-half play plays in football matches is highlighted by the simulation of halftime conclusions. According to preliminary research, some clubs might depend more on strong finishes to win games, which could cause the league rankings to change in this fictitious situation. This study not only emphasises how crucial it is to continue performing for the duration of the game, but it also encourages discussion about team tactics and how well they can be adjusted to suit various game developments. The dependability of these insights is increased by the absence of missing data, offering a strong basis for conjectural debates about team dynamics and league results."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "",
    "text": "This study explores how in-game data, like as shots on goal, fouls, and cards, affect match outcomes by looking at 380 matches from the English Premier League’s 2021–2022 season. We examine the critical impact these variables play in deciding whether a home or away side wins using Evan Gower’s painstakingly selected dataset. We examine these data and use logistic regression to forecast match outcomes, providing information about the dynamics of the game. This work opens the door for predictive modelling in sports analytics while also improving our knowledge of football strategy."
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "",
    "text": "This study explores how in-game data, like as shots on goal, fouls, and cards, affect match outcomes by looking at 380 matches from the English Premier League’s 2021–2022 season. We examine the critical impact these variables play in deciding whether a home or away side wins using Evan Gower’s painstakingly selected dataset. We examine these data and use logistic regression to forecast match outcomes, providing information about the dynamics of the game. This work opens the door for predictive modelling in sports analytics while also improving our knowledge of football strategy."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Introduction",
    "text": "Introduction\nEvan Gower’s work on Kaggle has made it possible to obtain statistics from 380 matches, giving us a detailed glimpse at the English Premier League season of 2021–2022. Along with comprehensive statistics for both home and away sides, such as goals, shots, fouls, and cards, it also provides important game information such team names, match dates, and referees. This dataset, which contains data on halftime performance as well as full-time results, is an invaluable resource for anyone wishing to examine the factors that affect football match outcomes, from individual player affects to team plans."
  },
  {
    "objectID": "index.html#question-1",
    "href": "index.html#question-1",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Question 1",
    "text": "Question 1\nWhat is the connection between in-game metrics such as shots on goal, fouls committed, and cards received, and the outcomes of soccer matches? Can these metrics help in creating a predictive model to forecast whether the match results will favor the home or away team?\n\nIntroduction\nThe first query explores the complex connections between in-game metrics—like shots on goal, fouls, and cards—and how those relationships affect the results of football matches. Our goal is to use these factors to investigate if they can accurately forecast match outcomes that will benefit the home team or the away team. This question is especially fascinating since it addresses fundamental football dynamics and provides information on how different gameplay elements affect a team’s eventual success or failure.\n\n\nApproach\nFirst, we do a logistic regression analysis to see how in-game metrics might be used to predict a home team’s outcome. We choose relevant attributes such as shots, shots on goal, fouls committed, and cards both the home and away teams have earned. To guarantee the robustness of the model, the dataset is divided into training and testing sets. The logistic regression model is then trained, and its effectiveness is assessed using an accuracy score and a confusion matrix. We are able to measure the effect of every in-game indicator on the probability that the home team will win thanks to this scientific approach.\nData Preparation and Pre-processing We begin the data preparation step by loading the entire football dataset, which includes a wealth of match information from the 2021–2022 English Premier League season. We convert the full-time result (FTR) into a binary target variable called “Result,” where a “1” denotes a home team win, to make our analysis easier. Then, we choose crucial elements that could have an impact on how the game turns out, like shots, shots on goal, fouls, and cards both the home and away teams receive. We then divided the dataset into training and testing sets, which prepared the stage for creating and assessing our prediction model. The data is ready for perceptive examination thanks to this careful preparation.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Creating a binary target variable 'Result' where 1 represents a home win ('H') and 0 otherwise\ndf['Result'] = (df['FTR'] == 'H').astype(int)\n\n# Feature selection\nfeatures = ['HS', 'AS', 'HST', 'AST', 'HF', 'AF', 'HY', 'AY', 'HR', 'AR']\nX = df[features]\ny = df['Result']\n\n# Splitting the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Logistic Regression model\nmodel = LogisticRegression(max_iter=1000)\nmodel.fit(X_train, y_train)\n\n# Predictions\ny_pred = model.predict(X_test)\n\n# Evaluating the model\naccuracy = accuracy_score(y_test, y_pred)\ncm = confusion_matrix(y_test, y_pred)\n\n\n# Plot 1: Feature importance visualization\ncoefficients = pd.DataFrame(model.coef_[0], X.columns, columns=['Coefficient']).sort_values(by='Coefficient', ascending=False)\nplt.figure(figsize=(10, 8))\nsns.barplot(x=coefficients['Coefficient'], y=coefficients.index)\nplt.title('Feature Importance in Predicting Home Team Wins')\nplt.xlabel('Coefficient Value')\nplt.ylabel('In-game Metrics')\nplt.show()\n\n\n\n\n\n\n\n\nFeature Importance Visualization by Logistic Regression\nA positive coefficient value (bar extending to the right) suggests that higher values of the corresponding metric increase the likelihood of the home team winning. For instance, a positive coefficient for Number of shots on Target by Home Team (HTS) indicates that the home side has a greater chance of winning if they have more shoots on target.\nOn the other hand, a negative coefficient value (bar extending to the left) indicates that the probability of the home side winning is decreased at greater levels of that statistic. For example, if Number of redcards recieved Home Team (HR) has a negative coefficient, it means that the home team’s chances of winning are likely to be lowered by committing more red cards received.\n\n# Plot 2: Confusion Matrix\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues')\nplt.title('Confusion Matrix for Home Team Win Prediction')\nplt.xlabel('Predicted Label')\nplt.ylabel('True Label')\nplt.show()\n\n# Print accuracy\nprint(f'Model Accuracy: {accuracy:.2f}')\n\n\n\n\n\n\n\n\nModel Accuracy: 0.78\n\n\nConfusion Matrix for Home Team Win Prediction\nThis chart shows how well the model guessed if the home team would win a soccer game. It’s like a report card for the model’s predictions. For example, if the model guessed that the home team wouldn’t win (maybe it thought the game would be a draw or the away team would win), and that was correct, that count goes in the top left corner. If the model thought the home team wouldn’t win, but they actually did, that count goes in the bottom left corner.\nOn the other hand, if the model predicted a home win and was right, that goes in the bottom right corner. But if it predicted a home win and was wrong, that goes in the top right corner.\n\n# Define the target variable - Home win (1) or not (0)\ndf['HomeWin'] = df['FTR'].apply(lambda x: 1 if x == 'H' else 0)\n\n# Select features of interest\nfeatures = ['HS', 'AS', 'HST', 'AST', 'HF', 'AF', 'HY', 'AY']\n\n# Compute correlation matrix for the features\ncorr = df[features].corr()\n\n# Heatmap of correlation between features\nplt.figure(figsize=(8, 6))\nsns.heatmap(corr, annot=True, cmap='coolwarm', fmt=\".2f\")\nplt.title(\"Feature Correlation Heatmap\")\nplt.show()\n\n\n\n\n\n\n\n\nFeature Correlation Heatmap This heatmap visualizes the correlation between different features (metrics) from the soccer dataset. Each cell in the heatmap shows the correlation coefficient between two features, ranging from -1 to 1. A correlation coefficient close to 1 implies a strong positive relationship (as one feature increases, the other tends to increase), close to -1 implies a strong negative relationship (as one feature increases, the other tends to decrease), and around 0 implies no linear relationship.\nFor example, if ‘HS’ (Home Shots) and ‘HST’ (Home Shots on Target) have a correlation coefficient close to 1, it means that when the home team takes more shots, they also tend to have more shots on target. Conversely, if ‘HS’ and ‘AF’ (Away Fouls) have a correlation coefficient close to -1, it suggests that as the home team takes more shots, the away team tends to commit fewer fouls, indicating a possible defensive strategy or play style difference when under pressure."
  },
  {
    "objectID": "index.html#question-2",
    "href": "index.html#question-2",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Question 2",
    "text": "Question 2\nHow do the outcomes of soccer matches vary under the premise that all games concluded at halftime? How does this disparity differ from team to team, and what is the influence of the overall outcome of the league championship?\n\nIntroduction\nIn question two, we analyze a hypothetical scenarios to offer practical insights derived from the European Premier League’s 22nd season. By exploring how matches might end at halftime, we aim to analyze the real-world dynamics of team performance. Specifically, we will investigate whether successful teams exhibit early aggression in the first half or stage comebacks in the second half, and whether team rankings reflect consistent performance or fluctuate based on halftime strategies. This analysis offers practical implications for coaching strategies, player development, and tactical approaches, providing actionable insights to enhance team performance and strategic decision-making in professional football.\n\n\nApproach\nInitially, we will employ traditional ranking methods based on full-time match results. Per the European Premier League, rank will be determined based on points per game, where a win is three points, a draw is one point, and a loss is zero points. When necessary, we will employ goal difference and total goals scored to determine team standings. Subsequently, we will simulate halftime outcomes for each match and recalculate team rankings using the same criteria applied for full-time results. An analysis will be conducted in two parts: first, comparing the disparities between the rankings derived from full-time and halftime outcomes; and secondly, focusing on the performance of the top three and bottom three teams in both scenarios to assess the influence of halftime outcomes on promotion, relegation, and the overall league championship. Through this comprehensive approach, we aim to provide insights into the dynamics of soccer match outcomes and their implications for team standings and league competitiveness.\nData Preparation and Pre-processing Data preparation for the analysis of the 2021-2022 European Premier League (EPL) season began with the calculation of points awarded to home and away teams based on match outcomes, adhering to the EPL’s point allocation system. Subsequently, the dataset was organized through grouping operations, which revealed instances of point ties among teams. To address this, a feature engineering process was employed to derive the goal difference metric, representing the difference between goals scored and goals conceded by each team. This involved aggregating match statistics to determine the net goals accumulated by each team throughout the season. By iteratively refining the dataset through these preprocessing steps, we ensured the readiness of the data for subsequent analysis, laying the groundwork for examining match outcomes and team dynamics during the 2021-2022 EPL season.\n\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['FTR'] == 'H':\n        return 3\n    elif row['FTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['FTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ft_ranking)\n\n              Team  Points  Ranking\n11        Man City      93        1\n10       Liverpool      92        2\n5          Chelsea      74        3\n16       Tottenham      71        4\n0          Arsenal      69        5\n12      Man United      58        6\n18        West Ham      56        7\n9        Leicester      52        8\n3         Brighton      51        9\n19          Wolves      51       10\n13       Newcastle      49       11\n6   Crystal Palace      48       12\n2        Brentford      46       13\n1      Aston Villa      45       14\n15     Southampton      40       15\n7          Everton      39       16\n8            Leeds      38       17\n4          Burnley      35       18\n17         Watford      23       19\n14         Norwich      22       20\n\n\nSince there are ties in points, we must move on to the second metric to determine official rankings\n\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['FTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['FTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['FTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['FTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'FTHG_x': 'HomeGoalsScored', 'FTAG_x': 'HomeGoalsConceded',\n                            'FTAG_y': 'AwayGoalsScored', 'FTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ft_ranking)\n\n              Team  Points  GoalDifference  Ranking\n0         Man City      93              73        1\n1        Liverpool      92              68        2\n2          Chelsea      74              43        3\n3        Tottenham      71              29        4\n4          Arsenal      69              13        5\n5       Man United      58               0        6\n6         West Ham      56               9        7\n7        Leicester      52               3        8\n8         Brighton      51              -2        9\n9           Wolves      51              -5       10\n10       Newcastle      49             -18       11\n11  Crystal Palace      48               4       12\n12       Brentford      46              -8       13\n13     Aston Villa      45              -2       14\n14     Southampton      40             -24       15\n15         Everton      39             -23       16\n16           Leeds      38             -37       17\n17         Burnley      35             -19       18\n18         Watford      23             -43       19\n19         Norwich      22             -61       20\n\n\nNow we repeat the process again with the half time results before beginning our analysis and discussion.\n\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['HTR'] == 'H':\n        return 3\n    elif row['HTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['HTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ht_ranking)\n\n              Team  Points  Ranking\n10       Liverpool      79        1\n11        Man City      77        2\n5          Chelsea      68        3\n16       Tottenham      65        4\n0          Arsenal      63        5\n15     Southampton      52        6\n12      Man United      51        7\n18        West Ham      50        8\n13       Newcastle      49        9\n6   Crystal Palace      48       10\n19          Wolves      48       11\n1      Aston Villa      47       12\n9        Leicester      45       13\n3         Brighton      44       14\n8            Leeds      40       15\n7          Everton      36       16\n2        Brentford      36       17\n4          Burnley      34       18\n14         Norwich      29       19\n17         Watford      28       20\n\n\nAgain, there are ties with the rankings when only looking at points based on half-time results. Therefore, we must look at goal difference as well.\n\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['HTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['HTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['HTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['HTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'HTHG_x': 'HomeGoalsScored', 'HTAG_x': 'HomeGoalsConceded',\n                            'HTAG_y': 'AwayGoalsScored', 'HTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ht_ranking)\n\n              Team  Points  GoalDifference  Ranking\n0        Liverpool      79              30        1\n1         Man City      77              34        2\n2          Chelsea      68              24        3\n3        Tottenham      65              16        4\n4          Arsenal      63              12        5\n5      Southampton      52              -8        6\n6       Man United      51              -3        7\n7         West Ham      50               6        8\n8        Newcastle      49               1        9\n10          Wolves      48               3       10\n9   Crystal Palace      48              -4       11\n11     Aston Villa      47              -4       12\n12       Leicester      45              -3       13\n13        Brighton      44              -6       14\n14           Leeds      40             -19       15\n16       Brentford      36             -13       16\n15         Everton      36             -14       17\n17         Burnley      34             -10       18\n18         Norwich      29             -23       19\n19         Watford      28             -19       20\n\n\n\n\nDiscussion"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This project was developed by [TAAAG Team] For INFO 523 - Data Mining and Discovery at the University of Arizona, taught by Dr. Greg Chism. The team is comprised of the following team members.\n\nTejas Bhawari: One sentence description of Team member 1 (e.g., year, major, etc.).\nGabriel Geffen: First-year Ph.D. student in civil engineering with an emphasis in traffic engineering.\nAyesha Khatun: One sentence description of Team member 3 (e.g., year, major, etc.).\nAlyssa Nether: A nondegree seeking graduate student exploring the realm of data science hoping to apply for the program in the future.\nAkash Srinivasan: One sentence description of Team member 4 (e.g., year, major, etc.)."
  },
  {
    "objectID": "presentation.html#exploring-the-complex-connections-between-in-game-metrics",
    "href": "presentation.html#exploring-the-complex-connections-between-in-game-metrics",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Exploring the complex connections between in-game metrics",
    "text": "Exploring the complex connections between in-game metrics\n\nCritical variablesData preparationAnalysis\n\n\n\nFTHG and FTAG are crucial indicators\nFTR serves as the target variable\nHS, AS, HST,and AST reflect attacking performance.\nHF, AF, HY, AY, HR,and AR all indicate team discipline and aggresion\n\n\n\n\nCombining match information with team-level season summaries\nThe consistency of the dataset ensures reliability of our analysis\n\n\n\n\nSplitting data into appropriate sets then applying regression techniques\nRegression techniques\nDiscovering patterns and relationships critical for building predictive models"
  },
  {
    "objectID": "presentation.html#code",
    "href": "presentation.html#code",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Code",
    "text": "Code\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Creating a binary target variable 'Result' where 1 represents a home win ('H') and 0 otherwise\ndf['Result'] = (df['FTR'] == 'H').astype(int)\n\n# Feature selection\nfeatures = ['HS', 'AS', 'HST', 'AST', 'HF', 'AF', 'HY', 'AY', 'HR', 'AR']\nX = df[features]\ny = df['Result']\n\n# Splitting the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Logistic Regression model\nmodel = LogisticRegression(max_iter=1000)\nmodel.fit(X_train, y_train)\n\n# Predictions\ny_pred = model.predict(X_test)\n\n# Evaluating the model\naccuracy = accuracy_score(y_test, y_pred)\ncm = confusion_matrix(y_test, y_pred)"
  },
  {
    "objectID": "presentation.html#feature-importance-visualization",
    "href": "presentation.html#feature-importance-visualization",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Feature Importance Visualization",
    "text": "Feature Importance Visualization\n\n# Plot 1: Feature importance visualization\ncoefficients = pd.DataFrame(model.coef_[0], X.columns, columns=['Coefficient']).sort_values(by='Coefficient', ascending=False)\nplt.figure(figsize=(10, 8))\nsns.barplot(x=coefficients['Coefficient'], y=coefficients.index)\nplt.title('Feature Importance in Predicting Home Team Wins')\nplt.xlabel('Coefficient Value')\nplt.ylabel('In-game Metrics')\nplt.show()"
  },
  {
    "objectID": "presentation.html#feature-importance-visualization-output",
    "href": "presentation.html#feature-importance-visualization-output",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Feature Importance Visualization",
    "text": "Feature Importance Visualization"
  },
  {
    "objectID": "presentation.html#confusion-matrix",
    "href": "presentation.html#confusion-matrix",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Confusion Matrix",
    "text": "Confusion Matrix\n\n# Plot 2: Confusion Matrix\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues')\nplt.title('Confusion Matrix for Home Team Win Prediction')\nplt.xlabel('Predicted Label')\nplt.ylabel('True Label')\nplt.show()\n\n# Print accuracy\nprint(f'Model Accuracy: {accuracy:.2f}')"
  },
  {
    "objectID": "presentation.html#confusion-matrix-output",
    "href": "presentation.html#confusion-matrix-output",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Confusion Matrix",
    "text": "Confusion Matrix\n\n\n\n\n\n\n\n\nModel Accuracy: 0.78"
  },
  {
    "objectID": "presentation.html#what-if-the-matches-ended-at-halftime",
    "href": "presentation.html#what-if-the-matches-ended-at-halftime",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "What if the matches ended at halftime?",
    "text": "What if the matches ended at halftime?\n\nCritical variablesData preparationAnalysis\n\n\n\nFTHG and FTAG are needed to determine team placements\nFTR denotes fthe final actual outcome\nHTHG, HTAG,and HTR are important as well\nHomeTeam and AwayTeam combined with the rest help determine the winner\n\n\n\n\nPerforming thorough checks and creating visualizations.\nMaking sure data has no missing values\n\n\n\n\nCreating a function to determine results of matches at halftime and using this re-calibration as a new baseline of analysis.\nChronologically organized data"
  },
  {
    "objectID": "presentation.html#code-1",
    "href": "presentation.html#code-1",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Code",
    "text": "Code\nData Prep\n\n\nShow the code\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['FTR'] == 'H':\n        return 3\n    elif row['FTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['FTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\n\nOffical Rankings\n\n\nShow the code\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['FTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['FTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['FTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['FTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'FTHG_x': 'HomeGoalsScored', 'FTAG_x': 'HomeGoalsConceded',\n                            'FTAG_y': 'AwayGoalsScored', 'FTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\n\nRepeated\n\n\nShow the code\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['HTR'] == 'H':\n        return 3\n    elif row['HTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['HTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\n\nRepeated with ties\n\n\nShow the code\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['HTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['HTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['HTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['HTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'HTHG_x': 'HomeGoalsScored', 'HTAG_x': 'HomeGoalsConceded',\n                            'HTAG_y': 'AwayGoalsScored', 'HTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})"
  },
  {
    "objectID": "presentation.html#plots",
    "href": "presentation.html#plots",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Plots",
    "text": "Plots"
  },
  {
    "objectID": "presentation.html#tables",
    "href": "presentation.html#tables",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Tables",
    "text": "Tables\nIf you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,"
  },
  {
    "objectID": "presentation.html#images",
    "href": "presentation.html#images",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Images",
    "text": "Images\n\nImage credit: Danielle Navarro, Percolate."
  },
  {
    "objectID": "presentation.html#math-expressions",
    "href": "presentation.html#math-expressions",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Math Expressions",
    "text": "Math Expressions\nYou can write LaTeX math expressions inside a pair of dollar signs, e.g. $\\alpha+\\beta$ renders \\(\\alpha + \\beta\\). You can use the display style with double dollar signs:\n$$\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i$$\n\\[\n\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i\n\\]\nLimitations:\n\nThe source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting $$ must appear in the very beginning of a line, followed immediately by a non-space character, and the ending $$ must be at the end of a line, led by a non-space character;\nThere should not be spaces after the opening $ or before the closing $."
  },
  {
    "objectID": "presentation.html#feeling-adventurous",
    "href": "presentation.html#feeling-adventurous",
    "title": "Premier League Performance Metrics and Results: A Dynamic Analysis",
    "section": "Feeling adventurous?",
    "text": "Feeling adventurous?\n\nYou are welcomed to use the default styling of the slides. In fact, that’s what I expect majority of you will do. You will differentiate yourself with the content of your presentation.\nBut some of you might want to play around with slide styling. Some solutions for this can be found at https://quarto.org/docs/presentations/revealjs."
  }
]