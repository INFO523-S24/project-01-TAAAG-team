{
  "hash": "d7cb141d8ea101f9f479d983e76d79d1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Premier League Performance Metrics and Results: A Dynamic Analysis'\nsubtitle: INFO 523 - Spring 2023 - Project 1\nauthor: 'Tejas Bhawari, Gabriel Geffen, Ayesha Khatun, Alyssa Nether, Akash Srinivasan'\ntitle-slide-attributes:\n  data-background-image: images/watercolour_sys02_img34_teacup-ocean.jpg\n  data-background-size: stretch\n  data-background-opacity: '0.7'\n  data-slide-number: none\nformat:\n  revealjs:\n    scrollable: true\n    theme:\n      - data/customtheming.scss\neditor: visual\nexecute:\n  echo: false\n---\n\n\n\n\n\n# Question 1\n\n## Exploring the complex connections between in-game metrics\n\n::: panel-tabset\n### Critical variables\n\n-   **FTHG** and **FTAG** are crucial indicators\n-   **FTR** serves as the target variable\n-   **HS**, **AS**, **HST**,and **AST** reflect attacking performance.\n-   **HF**, **AF**, **HY**, **AY**, **HR**,and **AR** all indicate team discipline and aggresion\n\n### Data preparation\n\n-   Combining match information with team-level season summaries\n-   The consistency of the dataset ensures reliability of our analysis\n\n### Analysis\n\n-   Splitting data into appropriate sets then applying regression techniques\n-   Regression techniques\n-   Discovering patterns and relationships critical for building predictive models\n:::\n\n## Code\n\n::: {#a9e808e8 .cell execution_count=4}\n``` {.python .cell-code .code-overflow-wrap}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Creating a binary target variable 'Result' where 1 represents a home win ('H') and 0 otherwise\ndf['Result'] = (df['FTR'] == 'H').astype(int)\n\n# Feature selection\nfeatures = ['HS', 'AS', 'HST', 'AST', 'HF', 'AF', 'HY', 'AY', 'HR', 'AR']\nX = df[features]\ny = df['Result']\n\n# Splitting the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Logistic Regression model\nmodel = LogisticRegression(max_iter=1000)\nmodel.fit(X_train, y_train)\n\n# Predictions\ny_pred = model.predict(X_test)\n\n# Evaluating the model\naccuracy = accuracy_score(y_test, y_pred)\ncm = confusion_matrix(y_test, y_pred)\n```\n:::\n\n\n## Feature Importance Visualization\n\n::: {#f3ee2a56 .cell output-location='slide' execution_count=5}\n``` {.python .cell-code .code-overflow-wrap}\n# Plot 1: Feature importance visualization\ncoefficients = pd.DataFrame(model.coef_[0], X.columns, columns=['Coefficient']).sort_values(by='Coefficient', ascending=False)\nplt.figure(figsize=(10, 8))\nsns.barplot(x=coefficients['Coefficient'], y=coefficients.index)\nplt.title('Feature Importance in Predicting Home Team Wins')\nplt.xlabel('Coefficient Value')\nplt.ylabel('In-game Metrics')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](presentation_files/figure-revealjs/cell-6-output-1.png){}\n:::\n:::\n\n\n## Confusion Matrix\n\n::: {#d5860006 .cell output-location='slide' execution_count=6}\n``` {.python .cell-code}\n# Plot 2: Confusion Matrix\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues')\nplt.title('Confusion Matrix for Home Team Win Prediction')\nplt.xlabel('Predicted Label')\nplt.ylabel('True Label')\nplt.show()\n\n# Print accuracy\nprint(f'Model Accuracy: {accuracy:.2f}')\n```\n\n::: {.cell-output .cell-output-display}\n![](presentation_files/figure-revealjs/cell-7-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nModel Accuracy: 0.78\n```\n:::\n:::\n\n\n# Question 2\n\n## What if the matches ended at halftime?\n\n::: panel-tabset\n### Critical variables\n\n-   **FTHG** and **FTAG** are needed to determine team placements\n-   **FTR** denotes fthe final actual outcome\n-   **HTHG**, **HTAG**,and **HTR** are important as well\n-   **HomeTeam** and **AwayTeam** combined with the rest help determine the winner\n\n### Data preparation\n\n-   Performing thorough checks and creating visualizations.\n-   Making sure data has no missing values\n\n### Analysis\n\n-   Creating a function to determine results of matches at halftime and using this re-calibration as a new baseline of analysis.\n-   Chronologically organized data\n:::\n\n## Code\n\n::: {#7befd956 .cell execution_count=7}\n``` {.python .cell-code .code-overflow-wrap code-fold=\"true\" code-summary=\"Data Prep & Pre-processing\"}\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['FTR'] == 'H':\n        return 3\n    elif row['FTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['FTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n```\n:::\n\n\n::: {#f346ff73 .cell execution_count=8}\n``` {.python .cell-code .code-overflow-wrap code-fold=\"true\" code-summary=\"Official Rankings\"}\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['FTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['FTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['FTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['FTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'FTHG_x': 'HomeGoalsScored', 'FTAG_x': 'HomeGoalsConceded',\n                            'FTAG_y': 'AwayGoalsScored', 'FTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n```\n:::\n\n\n::: {#a7be503b .cell execution_count=9}\n``` {.python .cell-code .code-overflow-wrap code-fold=\"true\" code-summary=\"Half Time Results\"}\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['HTR'] == 'H':\n        return 3\n    elif row['HTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['HTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n```\n:::\n\n\n::: {#c454665d .cell execution_count=10}\n``` {.python .cell-code .code-overflow-wrap code-fold=\"true\" code-summary=\"Repeated Half Time Results\"}\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['HTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['HTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['HTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['HTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'HTHG_x': 'HomeGoalsScored', 'HTAG_x': 'HomeGoalsConceded',\n                            'HTAG_y': 'AwayGoalsScored', 'HTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n```\n:::\n\n\n## Plots\n\n# A new section...\n\n## Tables\n\nIf you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,\n\n\n\n## Images\n\n![Image credit: Danielle Navarro, Percolate.](images/watercolour_sys02_img34_teacup-ocean.png){fig-align=\"center\" width=\"500\"}\n\n## Math Expressions {.smaller}\n\nYou can write LaTeX math expressions inside a pair of dollar signs, e.g.Â \\$\\\\alpha+\\\\beta\\$ renders $\\alpha + \\beta$. You can use the display style with double dollar signs:\n\n```         \n$$\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i$$\n```\n\n$$\n\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i\n$$\n\nLimitations:\n\n1.  The source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting `$$` must appear in the very beginning of a line, followed immediately by a non-space character, and the ending `$$` must be at the end of a line, led by a non-space character;\n\n2.  There should not be spaces after the opening `$` or before the closing `$`.\n\n# Wrap up\n\n## Feeling adventurous?\n\n-   You are welcomed to use the default styling of the slides. In fact, that's what I expect majority of you will do. You will differentiate yourself with the content of your presentation.\n\n-   But some of you might want to play around with slide styling. Some solutions for this can be found at https://quarto.org/docs/presentations/revealjs.\n\n",
    "supporting": [
      "presentation_files\\figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}