{
  "hash": "3710a208a1ddfd938c580c6bcaf9e8dd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Premier League Performance Metrics and Results: A Dynamic Analysis'\nsubtitle: INFO 523 - Spring 2023 - Project 1\nauthor: 'Tejas Bhawari, Gabriel Geffen, Ayesha Khatun, Alyssa Nether, Akash Srinivasan'\ntitle-slide-attributes:\n  data-background-image: images/watercolour_sys02_img34_teacup-ocean.jpg\n  data-background-size: stretch\n  data-background-opacity: '0.7'\n  data-slide-number: none\nformat:\n  revealjs:\n    scrollable: true\n    theme:\n      - data/customtheming.scss\neditor: visual\nexecute:\n  echo: false\n---\n\n\n\n\n\n# Question 1\n\n## Exploring the complex connections between in-game metrics\n\n::: panel-tabset\n### Critical variables\n\n-   **FTHG** and **FTAG** are crucial indicators\n-   **FTR** serves as the target variable\n-   **HS**, **AS**, **HST**,and **AST** reflect attacking performance.\n-   **HF**, **AF**, **HY**, **AY**, **HR**,and **AR** all indicate team discipline and aggresion\n\n### Data preparation\n\n-   Combining match information with team-level season summaries\n-   The consistency of the dataset ensures reliability of our analysis\n\n### Analysis\n\n-   Splitting data into appropriate sets then applying regression techniques\n-   Regression techniques\n-   Discovering patterns and relationships critical for building predictive models\n:::\n\n## Code\n\n::: {#89d907a7 .cell execution_count=4}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Creating a binary target variable 'Result' where 1 represents a home win ('H') and 0 otherwise\ndf['Result'] = (df['FTR'] == 'H').astype(int)\n\n# Feature selection\nfeatures = ['HS', 'AS', 'HST', 'AST', 'HF', 'AF', 'HY', 'AY', 'HR', 'AR']\nX = df[features]\ny = df['Result']\n\n# Splitting the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Logistic Regression model\nmodel = LogisticRegression(max_iter=1000)\nmodel.fit(X_train, y_train)\n\n# Predictions\ny_pred = model.predict(X_test)\n\n# Evaluating the model\naccuracy = accuracy_score(y_test, y_pred)\ncm = confusion_matrix(y_test, y_pred)\n```\n:::\n\n\n## Feature Importance Visualization\n\n::: {#53f36a09 .cell output-location='slide' execution_count=5}\n``` {.python .cell-code}\n# Plot 1: Feature importance visualization\ncoefficients = pd.DataFrame(model.coef_[0], X.columns, columns=['Coefficient']).sort_values(by='Coefficient', ascending=False)\nplt.figure(figsize=(10, 8))\nsns.barplot(x=coefficients['Coefficient'], y=coefficients.index)\nplt.title('Feature Importance in Predicting Home Team Wins')\nplt.xlabel('Coefficient Value')\nplt.ylabel('In-game Metrics')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](presentation_files/figure-revealjs/cell-6-output-1.png){}\n:::\n:::\n\n\n## Confusion Matrix\n\n::: {#64a00a07 .cell output-location='slide' execution_count=6}\n``` {.python .cell-code}\n# Plot 2: Confusion Matrix\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues')\nplt.title('Confusion Matrix for Home Team Win Prediction')\nplt.xlabel('Predicted Label')\nplt.ylabel('True Label')\nplt.show()\n\n# Print accuracy\nprint(f'Model Accuracy: {accuracy:.2f}')\n```\n\n::: {.cell-output .cell-output-display}\n![](presentation_files/figure-revealjs/cell-7-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nModel Accuracy: 0.78\n```\n:::\n:::\n\n\n# Question 2\n\n## What if the matches ended at halftime?\n\n::: panel-tabset\n\n### Critical variables\n\n-   **FTHG** and **FTAG** are needed to determine team placements\n-   **FTR** denotes fthe final actual outcome\n-   **HTHG**, **HTAG**,and **HTR** are important as well\n-   **HomeTeam** and **AwayTeam** combined with the rest help determine the winner\n\n### Data preparation\n\n-   Performing thorough checks and creating visualizations.\n-   Making sure data has no missing values\n\n### Analysis\n\n-  Creating a function to determine results of matches at halftime and using this recalibration as a new baseline of analysis.\n-   Chronologically organized data\n\n:::\n\n## Code\n\n::: panel-tabset\n\n###Data Prep\n\n::: {#37250cf7 .cell execution_count=7}\n``` {.python .cell-code}\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['FTR'] == 'H':\n        return 3\n    elif row['FTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['FTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ft_ranking)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Team  Points  Ranking\n11        Man City      93        1\n10       Liverpool      92        2\n5          Chelsea      74        3\n16       Tottenham      71        4\n0          Arsenal      69        5\n12      Man United      58        6\n18        West Ham      56        7\n9        Leicester      52        8\n3         Brighton      51        9\n19          Wolves      51       10\n13       Newcastle      49       11\n6   Crystal Palace      48       12\n2        Brentford      46       13\n1      Aston Villa      45       14\n15     Southampton      40       15\n7          Everton      39       16\n8            Leeds      38       17\n4          Burnley      35       18\n17         Watford      23       19\n14         Norwich      22       20\n```\n:::\n:::\n\n\n### Offical Rankings\n\n::: {#7c341a3f .cell execution_count=8}\n``` {.python .cell-code}\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['FTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['FTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['FTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['FTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'FTHG_x': 'HomeGoalsScored', 'FTAG_x': 'HomeGoalsConceded',\n                            'FTAG_y': 'AwayGoalsScored', 'FTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nft_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ft_ranking)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Team  Points  GoalDifference  Ranking\n0         Man City      93              73        1\n1        Liverpool      92              68        2\n2          Chelsea      74              43        3\n3        Tottenham      71              29        4\n4          Arsenal      69              13        5\n5       Man United      58               0        6\n6         West Ham      56               9        7\n7        Leicester      52               3        8\n8         Brighton      51              -2        9\n9           Wolves      51              -5       10\n10       Newcastle      49             -18       11\n11  Crystal Palace      48               4       12\n12       Brentford      46              -8       13\n13     Aston Villa      45              -2       14\n14     Southampton      40             -24       15\n15         Everton      39             -23       16\n16           Leeds      38             -37       17\n17         Burnley      35             -19       18\n18         Watford      23             -43       19\n19         Norwich      22             -61       20\n```\n:::\n:::\n\n\n### Repeated\n\n::: {#1e02f5ec .cell execution_count=9}\n``` {.python .cell-code}\n# Import libraries\nimport pandas as pd\n\n# Load the dataset\ndf = pd.read_csv('data/soccer21-22.csv')\n\n# Function to determine the winner based on points\ndef calculate_points(row):\n    if row['HTR'] == 'H':\n        return 3\n    elif row['HTR'] == 'D':\n        return 1\n    else:\n        return 0\n\n# Apply the function to calculate points for each match\ndf['HomePoints'] = df.apply(lambda row: calculate_points(row), axis = 1)\ndf['AwayPoints'] = df.apply(lambda row: 3 - calculate_points(row) if row['HTR'] != 'D' else 1, axis = 1)\n\n# Aggregate points for each team\nhome_points = df.groupby('HomeTeam')['HomePoints'].sum().reset_index()\naway_points = df.groupby('AwayTeam')['AwayPoints'].sum().reset_index()\n\n# Combine home and away points\nteam_points = pd.merge(home_points, away_points, how = 'outer', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points['TotalPoints'] = team_points['HomePoints'] + team_points['AwayPoints']\n\n# Sort team_points DataFrame based on TotalPoints\nteam_points = team_points.sort_values(by = 'TotalPoints', ascending = False)\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ht_ranking)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Team  Points  Ranking\n10       Liverpool      79        1\n11        Man City      77        2\n5          Chelsea      68        3\n16       Tottenham      65        4\n0          Arsenal      63        5\n15     Southampton      52        6\n12      Man United      51        7\n18        West Ham      50        8\n13       Newcastle      49        9\n6   Crystal Palace      48       10\n19          Wolves      48       11\n1      Aston Villa      47       12\n9        Leicester      45       13\n3         Brighton      44       14\n8            Leeds      40       15\n7          Everton      36       16\n2        Brentford      36       17\n4          Burnley      34       18\n14         Norwich      29       19\n17         Watford      28       20\n```\n:::\n:::\n\n\n### Repeated with ties\n\n::: {#aa324205 .cell execution_count=10}\n``` {.python .cell-code}\n# Aggregate goals scored and conceded for each team\nhome_goals_scored = df.groupby('HomeTeam')['HTHG'].sum().reset_index()\nhome_goals_conceded = df.groupby('HomeTeam')['HTAG'].sum().reset_index()\naway_goals_scored = df.groupby('AwayTeam')['HTAG'].sum().reset_index()\naway_goals_conceded = df.groupby('AwayTeam')['HTHG'].sum().reset_index()\n\n# Merge home and away goals scored and conceded with team_points\nteam_points = pd.merge(team_points, home_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, home_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'HomeTeam')\nteam_points = pd.merge(team_points, away_goals_scored, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\nteam_points = pd.merge(team_points, away_goals_conceded, how = 'left', left_on = 'HomeTeam', right_on = 'AwayTeam')\n\n# Rename columns during merge\nteam_points.rename(columns={'HTHG_x': 'HomeGoalsScored', 'HTAG_x': 'HomeGoalsConceded',\n                            'HTAG_y': 'AwayGoalsScored', 'HTHG_y': 'AwayGoalsConceded'}, inplace = True)\n\n# Fill NaN values with 0\nteam_points.fillna(0, inplace = True)\n\n# Calculate total goals scored and conceded\nteam_points['TotalGoalsScored'] = team_points['HomeGoalsScored'] + team_points['AwayGoalsScored']\nteam_points['TotalGoalsConceded'] = team_points['HomeGoalsConceded'] + team_points['AwayGoalsConceded']\n\n# Calculate goal difference\nteam_points['GoalDifference'] = team_points['TotalGoalsScored'] - team_points['TotalGoalsConceded']\n\n# Sort team_points DataFrame based on TotalPoints and GoalDifference\nteam_points = team_points.sort_values(by = ['TotalPoints', 'GoalDifference'], ascending = [False, False])\n\n# Create ranking DataFrame\nht_ranking = pd.DataFrame({\n    'Team': team_points['HomeTeam'],  # You can choose 'HomeTeam' or 'AwayTeam' because they are the same after merging\n    'Points': team_points['TotalPoints'],\n    'GoalDifference': team_points['GoalDifference'],\n    'Ranking': range(1, len(team_points) + 1)\n})\n\nprint(ht_ranking)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Team  Points  GoalDifference  Ranking\n0        Liverpool      79              30        1\n1         Man City      77              34        2\n2          Chelsea      68              24        3\n3        Tottenham      65              16        4\n4          Arsenal      63              12        5\n5      Southampton      52              -8        6\n6       Man United      51              -3        7\n7         West Ham      50               6        8\n8        Newcastle      49               1        9\n10          Wolves      48               3       10\n9   Crystal Palace      48              -4       11\n11     Aston Villa      47              -4       12\n12       Leicester      45              -3       13\n13        Brighton      44              -6       14\n14           Leeds      40             -19       15\n16       Brentford      36             -13       16\n15         Everton      36             -14       17\n17         Burnley      34             -10       18\n18         Norwich      29             -23       19\n19         Watford      28             -19       20\n```\n:::\n:::\n\n\n:::\n\n## Plots\n\n# A new section...\n\n## Tables\n\nIf you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,\n\n\n\n## Images\n\n![Image credit: Danielle Navarro, Percolate.](images/watercolour_sys02_img34_teacup-ocean.png){fig-align=\"center\" width=\"500\"}\n\n## Math Expressions {.smaller}\n\nYou can write LaTeX math expressions inside a pair of dollar signs, e.g. \\$\\\\alpha+\\\\beta\\$ renders $\\alpha + \\beta$. You can use the display style with double dollar signs:\n\n```         \n$$\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i$$\n```\n\n$$\n\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i\n$$\n\nLimitations:\n\n1.  The source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting `$$` must appear in the very beginning of a line, followed immediately by a non-space character, and the ending `$$` must be at the end of a line, led by a non-space character;\n\n2.  There should not be spaces after the opening `$` or before the closing `$`.\n\n# Wrap up\n\n## Feeling adventurous?\n\n-   You are welcomed to use the default styling of the slides. In fact, that's what I expect majority of you will do. You will differentiate yourself with the content of your presentation.\n\n-   But some of you might want to play around with slide styling. Some solutions for this can be found at https://quarto.org/docs/presentations/revealjs.\n\n",
    "supporting": [
      "presentation_files\\figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}